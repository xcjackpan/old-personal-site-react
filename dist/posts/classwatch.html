<!doctype HTML>

<html>
<head>
	<!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-113805187-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-113805187-1');
	</script>

	<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
	<link rel="manifest" href="../site.webmanifest">
	<link rel="mask-icon" href="../safari-pinned-tab.svg" color="#5bbad5">
	<meta name="msapplication-TileColor" content="#da532c">
	<meta name="theme-color" content="#ffffff">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
	<link rel='stylesheet' href='styles/style.css'>
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>ClassWatch – Problem Analysis</title>
</head>

<body>

	<h1 class="title">ClassWatch – Problem Analysis</h1>
	<p class="date">08/01/2018</p>

	<p class="text">
		This summer, a fellow Waterloo student and I launched ClassWatch, a web application made specifically for UW students to help with course enrolment. ClassWatch was an idea I had when I first started university – a product of me desperately trying to switch into a zoology elective course. 

		<br/><br/>

		The original idea was basically the same as it is now: you’d find the section you wanted to get into, enter your email, and it would notify you when there was an open spot. In the few days after launch, ClassWatch peaked at around 1,600 pageviews and over 700 unique users – which, to be honest, was way more than I had expected.

		<br/><br/>

		I want to take the time now to formalize some of what I've learned via a blog post. To do this, I’d like to focus on how I solved one particular problem and – as cliché as it sounds – reflect on what I learned along the way.
	</p>

	<h3 class="subheading">The Problem</h3>

	<p class="text">
		For some context, ClassWatch is a static React front-end backed by a Node.js server connected to a database hosted via Google’s Firebase. I had never worked with any back-end programming before this summer. When it came time to work on ClassWatch’s server, I was essentially learning as I went along – of course with the help of StackOverflow.

		<br/><br/><br/>

		The problem was how to receive and then respond to search requests from the front-end. Since the server was scraping a website to get the search result, it would take a few seconds for the server to produce a result after receiving a query. In essence, we needed a way to have the front-end make the request, wait, and then receive the results. 

		<br/><br/><br/>

		I knew enough about GET and POST requests to make that my starting off point, but it took a while to work. While I was stuck on this, I ran through several iterations of the code that – at the very least – got the job done.
	</p>

	<h3 class="subheading">My Solutions</h3>

	<p class="text">
		<strong>1. Using setTimeout()</strong>

		<br/><br/>

		This was the first "solution" I could think of; I'm using the term "solution" very loosely here. With this method, when the user clicked “search”, the front-end would make a POST request with the search query and a GET request for the results at the same time. To deal with the delay, the GET request was on a fixed timeout so that there would be enough time to get the results. 

		<br/><br/>

		Though I was able to make successful searches, needless to say I didn’t let this code sit for very long.

		<br/><br/><br/>

		<strong>2. A promise and a custom eventEmitter</strong>

		<br/><br/>

		I had never used Promises before, so they took some fiddling before I could get it to work the way I wanted to. But once I got them working, it was just a better version of my hacky setTimeout() attempt. The search query would be passed with a POST request, and then a GET request would also be sent to the server. At that particular endpoint, the server would then create a Promise that would resolve on a certain event. The trick here was that once the server was done its scrape and had the search results, that event would be emitted and the Promise would resolve and send the results back.

		<br/><br/><br/>

	</p>

		<div class="image">
			<img src="img/promisesnippet.png" class="img959x491">
		</div>

	<p class="text">
		<strong>3. URL queries</strong>

		<br/><br/>

		The first two solutions had one other problem I haven't mentioned. Since the server would search using the query from the POST request and had to send that data back via the GET request, the server was dealing with two separate requests from the front-end to different endpoints. To pass the results between two listeners on two different endpoints, I was storing the search results in a global variable. This works for when only one person is searching at a time, but since we wanted the app to be available to all UW students – something had to change. 

		<br/><br/><br/>

		I finally found the solution that would let me handle the searching all on one endpoint: URL query parameters. I stumbled on this while doing some reading on the side, trying to optimize how the server was running. Previously, I had no way to pass the search query to the server without sending it through a POST form. Now, by embedding the queries into the URL for the endpoint as a query string, I could just get the search query from the URL of the GET request's endpoint, make the search with <i>async</i>, and return the results.

	</p>

	<div class="image">
		<img src="img/urlsnippet.png" class="img959x491">
	</div>

	<h3 class="subheading">Final Remarks</h3>

	<p class="text">
		That third solution is actually still live right now, and it’s worked really well so far. I’m really happy with the solution and the process I went through to find it. Coming out of just this one problem, I was way more familiar with back-end architecture than before.

		<br/><br/>

		I’d really like to write more about ClassWatch in the future, since I had such a great time working on it and learned so much as well. I feel like taking the time to write these kinds of posts really helps me to solidify what I've learned – which is really the whole point of doing these projects in the first place. That, and building something cool.
	</p>

	<div class="image">
		<img src="img/classwatchsplash.png" class="img959x491">
	</div>
	<p class="bottom-caption">The ClassWatch splash page.</p>

</body>